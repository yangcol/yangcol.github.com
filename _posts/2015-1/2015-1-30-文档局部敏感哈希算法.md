---
layout: post
category : algorithm
tagline: "海量数据处理读书笔记"
tags : [哈希, 最小哈希, 大数据, LSH, 局部敏感哈希]
---
{% include JB/setup %}

本文介绍文档局部敏感哈希算法。

## 最小哈希(min hashing)
最小哈希的目的是为特征生成特征签名。为什么需要特征签名呢？举个例子，对于一篇千字文章，如果我想比较和另一篇文章的相似度，那么用直观的方法进行比较是很困难的。所以，需要对文章进行特征提取，提取的特征集合通常被称作签名，也有指纹的叫法。

先给出最小哈希的计算方法：
考虑集合与特征

元素| S1|S2|S3|S4
-----|---|---|---|---
a|1|0|0|1
b|0|0|1|0
c|0|1|0|1
d|1|0|1|1
e|0|0|1|0

S1有特征{a,d}
S2有特征{c}
S3有特征{b,d,e}
S4有特征{a,c,d}

首先对行进行随机排(洗牌，shuffle)(稍后介绍这么做的意义)。任意一列的最小哈希值是元素Si拥有的第一个特征。

元素| S1|S2|S3|S4
-----|---|---|---|---
b|0|0|<font color="#F00">1</font>|0
e|0|0|1|0
a|<font color="#F00">1</font>|0|0|<font color="#F00">1</font>
c|0|<font color="#F00">1</font>|0|1
d|1|0|1|1

以上是矩阵的一个行排列转换结果
我们有h(S1) = a, h(S2) = c, h(S3) = b, h(S4) = a

那么，如果两个元素，他们的特征相似（拥有若干个相同的特征），那么，他们的最小哈希值***更有可能***相同。

这个“更有可能”的概率是多大呢？
我们以集合S1和S2所对应的列为例，它们每个元素所在的行按照所有可能的结果分成如下三类：

(1)x类
	同一行的两个元素都是1。比如S3,S4的d特征。

(2)y类
	同一行的两个元素不一样（一个为0，一个为1）。

(3)z类
	同一行的两个元素值都为0。也就是两个元素都不具有这个特征。

对S1和S2对应的每行就是这3种类型。h(S1) = h(S2)的概率多大呢？

z类的情况不会对h(S1)和h(S2)产生影响，因为这时候，最小哈希会跳过这些0值。所以，h(S1) = h(S2)的概率可以用x / (x+y)来表示。这个就是S1与S2的Jaccard相似度。

	Jaccard相似度是两个集合的交集与并集的比值。S1有特征{a,d}，S3有特征{b,d,e}，那么S1与S3的Jaccard相似度是 ||S1 ∩ S3|| / ||S1 ∪ S3||，也就是||{d}|| / ||{a,b,d,e}|| = 1/4


##最小哈希签名
还是上面介绍的矩阵，我们知道了，如果只进行一次最小哈希计算，那么两个元素的最小哈希值相同的概率是x / (x + y)。为了降低这个概率，我们可以进行多次的最小哈希值计算，那么，两个元素的最小哈希值相同的概率会变成 (x / (x+y)) ^ n。n是我们计算最小哈希值的次数。 （这种现象在计算系统的可靠性中尤为显著，一个串行系统的可靠性是所有部件可靠性的乘积。在一个5000台机器的集群，如果每个机器是99.99%的可靠性的，那么，这个集群没有机器出问题的可靠性是60.65%）

下面继续回到最小哈希签名，我们对上面的矩阵M做n次洗牌，然后每次使用一个哈希函数h1 ~ hn，则可以构建S(S是S1~Sn的集合)的最小哈希签名向量[h1(S), h2(S), ···, hn(S)]，该向量通常写成列向量方式。因此，基于矩阵M可以构建一个签名矩阵。

签名矩阵和M的列数相同，但是行数只有n。对于行很多（上万量级）的矩阵来说，n是很小的值。达到了实现签名的目的（可以用签名矩阵来表征实际上的矩阵M）。


